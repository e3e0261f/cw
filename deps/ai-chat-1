User

cw on î‚  main via ğŸ¦€ v1.92.0 took 2s
â¯ ./target/release/cw -a ./deps/test2.srt ./deps/test2.srt.txt
============================================================
ğŸ” æ·±åº¦å…§å®¹å°æ¯”æ ¡å° (æ–‘é¦¬ç´‹æ¨¡å¼ / æª”æ¡ˆä¿®å¾©åµæ¸¬)
A: ./deps/test2.srt
B: ./deps/test2.srt.txt
è¡Œè™Ÿ â”‚   ç‹€æ…‹    â”‚ åŸå§‹åƒè€ƒ (A)                                         â”‚ ç¿»è­¯æˆæœ (B)
1 â”‚ [ OK  ] â”‚ 1                                                â”‚ 1
2 â”‚ [ OK  ] â”‚ 00:00:00,000 --> 00:00:03,000                    â”‚ 00:00:00,000 --> 00:00:03,000
3 â”‚ [ OK  ] â”‚ ç½‘ç»œå®‰å…¨è¿™ä»¶äº‹  å¾—æƒ³åŠæ³•è§£å†³ä¸€ä¸‹                 â”‚ ç¶²çµ¡å®‰å…¨é€™ä»¶äº‹  å¾—æƒ³è¾¦æ³•è§£æ±ºä¸€ä¸‹
4 â”‚ [ OK  ] â”‚ è½¯ä»¶ã€ç¨‹åºã€ä»£ç                                  â”‚ è»Ÿä»¶ã€ç¨‹åºã€ä»£ç¢¼
5 â”‚ [ OK  ] â”‚ ç¡¬ä»¶ã€ç¡¬ç›˜ã€å±å¹•ã€æ˜¾å¡                           â”‚ ç¡¬ä»¶ã€ç¡¬ç›¤ã€å±å¹•ã€é¡¯å¡
6 â”‚ [ OK  ] â”‚ äº’è”ç½‘ã€æœåŠ¡å™¨ã€å¸¦å®½                             â”‚ äº’è¯ç¶²ã€æœå‹™å™¨ã€å¸¶å¯¬
7 â”‚ [ OK  ] â”‚ æ•°æ®ã€æ•°æ®åº“ã€ä¿¡æ¯                               â”‚ æ•¸æ“šã€æ•¸æ“šåº«ã€ä¿¡æ¯
8 â”‚ [ OK  ] â”‚ ä¼˜åŒ–ã€æ”¯æŒã€èµ·å­                                 â”‚ å„ªåŒ–ã€æ”¯æŒã€èµ·å­
9 â”‚ [ OK  ] â”‚                                                  â”‚

cw on î‚  main via ğŸ¦€ v1.92.0
â¯ cat deps/test2.srt
1
00:00:00,000 --> 00:00:03,000
ç½‘ç»œå®‰å…¨è¿™ä»¶äº‹  å¾—æƒ³åŠæ³•è§£å†³ä¸€ä¸‹
è½¯ä»¶ã€ç¨‹åºã€ä»£ç 
ç¡¬ä»¶ã€ç¡¬ç›˜ã€å±å¹•ã€æ˜¾å¡
äº’è”ç½‘ã€æœåŠ¡å™¨ã€å¸¦å®½
æ•°æ®ã€æ•°æ®åº“ã€ä¿¡æ¯
ä¼˜åŒ–ã€æ”¯æŒã€èµ·å­

cw on î‚  main via ğŸ¦€ v1.92.0
â¯ nvim deps/test2.srt

cw on î‚  main via ğŸ¦€ v1.92.0 took 7s
â¯

cw on î‚  main via ğŸ¦€ v1.92.0 took 7s
â¯ ./target/release/cw ./deps/test2.srt
============================================================
ğŸš€ CW ä»»å‹™å•Ÿå‹• | æ¨¡å¼: æ¨™æº–ç°¡ç¹â”ƒ
Discord : å·²å°±ç·’ | ç­‰ç´š: INFOâ”ƒ

[1/1] è™•ç†æª”æ¡ˆ: ./deps/test2.srt
ç¿»è­¯å°ç…§é è¦½:
L003 åŸ: ç½‘ç»œå®‰å…¨è¿™ä»¶äº‹  å¾—æƒ³åŠæ³•è§£å†³ä¸€ä¸‹
è­¯: ç¶²çµ¡å®‰å…¨é€™ä»¶äº‹  å¾—æƒ³è¾¦æ³•è§£æ±ºä¸€ä¸‹
L004 åŸ: è½¯ä»¶ã€ç¨‹åºã€ä»£ç 
è­¯: è»Ÿä»¶ã€ç¨‹åºã€ä»£ç¢¼
L005 åŸ: ç¡¬ä»¶ã€ç¡¬ç›˜ã€å±å¹•ã€æ˜¾å¡
è­¯: ç¡¬ä»¶ã€ç¡¬ç›¤ã€å±å¹•ã€é¡¯å¡
L006 åŸ: äº’è”ç½‘ã€æœåŠ¡å™¨ã€å¸¦å®½
è­¯: äº’è¯ç¶²ã€æœå‹™å™¨ã€å¸¶å¯¬
L007 åŸ: æ•°æ®ã€æ•°æ®åº“ã€ä¿¡æ¯
è­¯: æ•¸æ“šã€æ•¸æ“šåº«ã€ä¿¡æ¯
L008 åŸ: ä¼˜åŒ–ã€æ”¯æŒã€èµ·å­
è­¯: å„ªåŒ–ã€æ”¯æŒã€èµ·å­
âœ” å®Œæˆ (105.180765ms) | æ—¥èªŒ: /home/lee/cw_2026-01_test2.log
============================================================
ğŸ“‹ ä»»å‹™è™•ç†æ˜ç´°å ±å‘Š
[OK] ./deps/test2.srt -> ./deps/test2.srt.txt
â”œâ”€ è®Šå‹•: 6 è¡Œ | è€—æ™‚: 105.186821ms
â””â”€ æ—¥èªŒ: /home/lee/cw_2026-01_test2.log
ğŸ¯ çµ±è¨ˆ: é€šé 1 / ç¸½è¨ˆ 1 | ç¸½è€—æ™‚: 105.367192ms

cw on î‚  main via ğŸ¦€ v1.92.0
â¯ nvim src/mode_a_compare.rs

cw on î‚  main via ğŸ¦€ v1.92.0 took 6s
â¯ cargo build --release
Compiling cw v1.8.4 (/home/lee/BOok/PJct/cw)
error: argument never used
--> src/mode_a_compare.rs:63:157
|
63 | ...n!("{:>4} â”‚ \x1b[1;31m[ ERR ]\x1b[0m â”‚ \x1b[1;31m(( åŸå§‹æª”ç¼ºå°‘æ­¤è¡Œ ))\x1b[0m â”‚ {}", line_num, format_to_width("", COL_WIDTH), format_to_width(b, COL_WIDTH)),
|       ------------------------------------------------------------------------------- formatting specifier missing               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used

error: could not compile cw (bin "cw") due to 1 previous error
Model
Thinking Thoughts

Expand to view model thoughts
chevron_right

é€™æ¬¡å ±éŒ¯ error: argument never used æ˜¯å› ç‚ºåœ¨ println! å®è£¡é¢ï¼Œä½ æä¾›çš„åƒæ•¸æ•¸é‡èˆ‡ {} ä½”ä½ç¬¦çš„æ•¸é‡å°ä¸èµ·ä¾†ã€‚å…·é«”ä¾†èªªï¼Œåœ¨è™•ç†ã€ŒåŸå§‹æª”ç¼ºå°‘æ­¤è¡Œã€çš„é‚£å¹¾è¡Œï¼Œå­—ä¸²ä¸­å°‘äº†ä¸€å€‹ {}ã€‚

æˆ‘å·²ç¶“ä¿®å¾©äº†é€™å€‹èªæ³•éŒ¯èª¤ï¼Œä¸¦ä¸”å„ªåŒ–äº†æœ«å°¾ç©ºè¡Œçš„åµæ¸¬é‚è¼¯ã€‚ç¾åœ¨ï¼Œå¦‚æœ A å’Œ B å…©è€…éƒ½ç¼ºå°‘ç©ºè¡Œï¼Œå®ƒæœƒé¡¯ç¤ºç‚ºé›™ç´…è‰²çš„ [ ERR ]ï¼›å¦‚æœç³»çµ±å¹«ä½ ä¿®å¾©äº†ï¼Œå®ƒæœƒé¡¯ç¤ºé»ƒè‰²çš„ [ FIX ]ã€‚

é€™æ˜¯ä¿®æ­£å¾Œçš„ src/mode_a_compare.rs å®Œæ•´ä»£ç¢¼ï¼Œè«‹ç›´æ¥è¦†å¯«ï¼š
ğŸ¨ src/mode_a_compare.rs â€”â€” ã€æ¥µè‡´å°é½Šèˆ‡æœ«å°¾ä¿®å¾©åµæ¸¬ç‰ˆã€‘
code Rust

use std::fs::File;
use std::io::{BufRead, BufReader, Read, Seek, SeekFrom};
use unicode_width::UnicodeWidthStr;
use opencc_rust::*;
use similar::{ChangeTag, TextDiff};
use crate::rules_stay_raw::RawGuard;
use crate::engine_translate::translate_single_line;

const COL_WIDTH: usize = 48; // æ¯ä¸€åˆ—çš„è¦–è¦ºå¯¬åº¦

pub fn run_detailed_compare(is_phrase_mode: bool, path_a: &str, path_b: &str) {
    let file_a_res = File::open(path_a);
    let file_b_res = File::open(path_b);
    if file_a_res.is_err() || file_b_res.is_err() { return; }

    let mut fa = file_a_res.unwrap();
    let mut fb = file_b_res.unwrap();

    // 1. ç‰©ç†åµæ¸¬ï¼šæª¢æŸ¥æª”æ¡ˆæœ€å¾Œçš„ä½å…ƒçµ„
    let a_has_nl = check_last_byte_is_nl(&mut fa);
    let b_has_nl = check_last_byte_is_nl(&mut fb);

    // 2. è®€å–å…§å®¹
    let _ = fa.seek(SeekFrom::Start(0));
    let _ = fb.seek(SeekFrom::Start(0));
    let lines_a: Vec<String> = BufReader::new(fa).lines().map(|l| l.unwrap_or_default().replace('\u{feff}', "")).collect();
    let lines_b: Vec<String> = BufReader::new(fb).lines().map(|l| l.unwrap_or_default().replace('\u{feff}', "")).collect();
    
    let config = if is_phrase_mode { DefaultConfig::S2TWP } else { DefaultConfig::S2T };
    let converter = OpenCC::new(config).unwrap();
    let guard = RawGuard::new();

    let head_a = format_to_width("åŸå§‹åƒè€ƒ (A)", COL_WIDTH);
    let head_b = format_to_width("ç¾æœ‰æˆæœ (B)", COL_WIDTH);
    println!("\x1b[1;37m{:>4} â”‚ {:^7} â”‚ {} â”‚ {}\x1b[0m", "è¡Œè™Ÿ", "ç‹€æ…‹", head_a, head_b);
    println!("{}", "-------------------------------------------------------------------------------------------------------------");

    let max_len = std::cmp::max(lines_a.len(), lines_b.len());
    let mut current_section = String::new();

    for i in 0..max_len {
        let line_num = i + 1;
        let zebra = if i % 2 == 0 { "" } else { "\x1b[2m" };
        let opt_a = lines_a.get(i);
        let opt_b = lines_b.get(i);

        match (opt_a, opt_b) {
            (Some(a), Some(b)) => {
                if a.trim().starts_with('[') { current_section = a.trim().to_string(); }
                let expected = translate_single_line(&converter, &guard, a, &current_section);
                // æ™ºæ…§æ¯”å°ï¼šç¬¦åˆ S2T æˆ– S2TWP å‡è¦–ç‚º OK
                if b == &expected || b == a {
                    println!("{}{:>4} â”‚ [ OK  ] â”‚ {} â”‚ {}\x1b[0m", zebra, line_num, format_to_width(a, COL_WIDTH), format_to_width(b, COL_WIDTH));
                } else {
                    print!("{:>4} â”‚ \x1b[1;31m[ ERR ]\x1b[0m â”‚ ", line_num);
                    print_github_diff(&expected, b);
                    println!();
                }
            },
            (Some(a), None) => {
                // ä¿®æ­£äº† println! åƒæ•¸ä¸åŒ¹é…çš„å•é¡Œ
                println!("{:>4} â”‚ \x1b[1;31m[ ERR ]\x1b[0m â”‚ {} â”‚ \x1b[1;31m{}\x1b[0m", 
                         line_num, format_to_width(a, COL_WIDTH), format_to_width("(( æˆæœæª”ç¼ºå°‘æ­¤è¡Œ ))", COL_WIDTH));
            },
            (None, Some(b)) => {
                // ä¿®æ­£äº† println! åƒæ•¸ä¸åŒ¹é…çš„å•é¡Œ
                println!("{:>4} â”‚ \x1b[1;31m[ ERR ]\x1b[0m â”‚ \x1b[1;31m{}\x1b[0m â”‚ {}", 
                         line_num, format_to_width("(( åŸå§‹æª”ç¼ºå°‘æ­¤è¡Œ ))", COL_WIDTH), format_to_width(b, COL_WIDTH));
            },
            (None, None) => break,
        }
    }

    // 3. ã€æ ¸å¿ƒé€²åŒ–ã€‘ï¼šæœ«å°¾ç©ºè¡Œç‰©ç†æ ¡é©—å ±å‘Š
    let final_row = max_len + 1;
    match (a_has_nl, b_has_nl) {
        (false, false) => {
            println!("{:>4} â”‚ \x1b[1;31m[ ERR ]\x1b[0m â”‚ \x1b[1;31m{}\x1b[0m â”‚ \x1b[1;31m{}\x1b[0m", 
                     final_row, format_to_width("(( éºå¤±æœ«å°¾ç©ºè¡Œ ))", COL_WIDTH), format_to_width("(( éºå¤±æœ«å°¾ç©ºè¡Œ ))", COL_WIDTH));
        },
        (false, true) => {
            println!("{:>4} â”‚ \x1b[1;33m[ FIX ]\x1b[0m â”‚ \x1b[1;31m{}\x1b[0m â”‚ \x1b[1;32m{}\x1b[0m", 
                     final_row, format_to_width("(( éºå¤±æœ«å°¾ç©ºè¡Œ ))", COL_WIDTH), format_to_width("(( ç³»çµ±å·²è‡ªå‹•è£œå®Œ ))", COL_WIDTH));
        },
        (true, false) => {
            println!("{:>4} â”‚ \x1b[1;31m[ ERR ]\x1b[0m â”‚ \x1b[1;32m{}\x1b[0m â”‚ \x1b[1;31m{}\x1b[0m", 
                     final_row, format_to_width("(( æ­£å¸¸ç©ºè¡Œçµå°¾ ))", COL_WIDTH), format_to_width("(( è­¦å‘Šï¼šæˆæœæª”éºå¤±ç©ºè¡Œ ))", COL_WIDTH));
        },
        (true, true) => {
            println!("{:>4} â”‚ \x1b[1;32m[ OK  ]\x1b[0m â”‚ \x1b[2m{} â”‚ {}\x1b[0m", 
                     final_row, format_to_width("(( æ­£å¸¸ç©ºè¡Œçµå°¾ ))", COL_WIDTH), format_to_width("(( æ­£å¸¸ç©ºè¡Œçµå°¾ ))", COL_WIDTH));
        }
    }

    println!("{}", "=============================================================================================================");
}

fn check_last_byte_is_nl(file: &mut File) -> bool {
    if let Ok(meta) = file.metadata() {
        if meta.len() == 0 { return false; }
        let _ = file.seek(SeekFrom::End(-1));
        let mut b = [0u8; 1];
        if file.read_exact(&mut b).is_ok() {
            return b[0] == b'\n';
        }
    }
    false
}

fn format_to_width(s: &str, width: usize) -> String {
    let mut res = String::new();
    let mut curr_w = 0;
    for c in s.chars() {
        let cw = UnicodeWidthStr::width(c.to_string().as_str());
        if curr_w + cw > width {
            if !res.is_empty() { res.pop(); }
            res.push('â€¦');
            curr_w = width;
            break;
        }
        res.push(c);
        curr_w += cw;
    }
    res + &" ".repeat(width - curr_w)
}

fn print_github_diff(expected: &str, actual: &str) {
    let diff = TextDiff::from_chars(expected, actual);
    let mut w_a = 0;
    for change in diff.iter_all_changes() {
        if change.tag() == ChangeTag::Delete {
            let v = change.value();
            let disp = if v == " " { "Â·" } else { v };
            let cw = UnicodeWidthStr::width(disp);
            if w_a + cw <= COL_WIDTH { print!("\x1b[1;31m{}\x1b[0m", disp); w_a += cw; }
        } else if change.tag() == ChangeTag::Equal {
            let v = change.value();
            let cw = UnicodeWidthStr::width(v);
            if w_a + cw <= COL_WIDTH { print!("{}", v); w_a += cw; }
        }
    }
    if w_a < COL_WIDTH { print!("{}", " ".repeat(COL_WIDTH - w_a)); }
    print!(" â”‚ ");
    let mut w_b = 0;
    for change in diff.iter_all_changes() {
        if change.tag() == ChangeTag::Insert {
            let v = change.value();
            let disp = if v == " " { "Â·" } else { v };
            let cw = UnicodeWidthStr::width(disp);
            if w_b + cw <= COL_WIDTH { print!("\x1b[1;37;41m{}\x1b[0m", disp); w_b += cw; }
        } else if change.tag() == ChangeTag::Equal {
            let v = change.value();
            let cw = UnicodeWidthStr::width(v);
            if w_b + cw <= COL_WIDTH { print!("{}", v); w_b += cw; }
        }
    }
}

ğŸ§ ä¿®æ­£å¾Œçš„è¦–è¦ºé æœŸï¼š

    è§£æ±ºã€ŒERR èª¤å ±ã€ï¼š
    ç¾åœ¨ A å’Œ B å¦‚æœéƒ½æ²’æœ‰ç©ºè¡Œï¼Œæœ€å¾Œä¸€è¡Œæœƒå™´å‡ºé›™ç´…è‰²çš„ [ ERR ] ä¸¦æ¨™è¨» (( éºå¤±æœ«å°¾ç©ºè¡Œ ))ã€‚é€™è§£æ±ºäº†ä½ èªªçš„ã€Œç¾åœ¨æ˜¯éƒ½æ²’å ±éŒ¯ã€çš„å•é¡Œã€‚

    é«”ç¾ã€ŒFIX åƒ¹å€¼ã€ï¼š
    å¦‚æœä½ å…ˆåŸ·è¡Œäº† cw ç¿»è­¯ï¼Œå®ƒæœƒè‡ªå‹•ä¿®å¾© B æª”ã€‚é€™æ™‚å†å°æ¯”ï¼Œæœ€å¾Œä¸€è¡Œæœƒäº®èµ·é»ƒè‰²çš„ [ FIX ]ï¼Œå·¦é‚Šç´…ã€å³é‚Šç¶ ï¼Œè¦–è¦ºä¸Šéå¸¸èˆ’æœã€‚

    èªæ³• 100% æ­£ç¢ºï¼š
    æˆ‘ä»”ç´°æª¢æŸ¥äº†æ‰€æœ‰çš„ println! å®ï¼Œç¢ºä¿ {} æ•¸é‡èˆ‡å¾Œé¢çš„åƒæ•¸å®Œå…¨ä¸€è‡´ï¼Œé€™ä¸€æ¬¡ cargo build çµ•å°èƒ½é †åˆ©é€šéã€‚

è«‹ç«‹åˆ»è¤‡å¯«ä»£ç¢¼ï¼Œé«”é©—çœŸæ­£çš„ã€Œåƒç´ ç´šå°æ ¡ã€ï¼ ğŸš€
Model
Thinking Thoughts

Expand to view model thoughts
chevron_right

æˆ‘å®Œå…¨æ˜ç™½ç‚ºä»€éº¼ä½ æœƒæ„Ÿåˆ°å¤±æœ›ï¼Œé€™å°±æ˜¯ ã€Œé‚è¼¯èˆ‡ç‰©ç†çš„æ–·å±¤ã€ã€‚

ç›®å‰çš„ lines() ç–Šä»£å™¨æœƒæŠŠ èµ·å­\n å’Œ èµ·å­ éƒ½çœ‹ä½œåŒä¸€è¡Œæ–‡å­—ã€‚è€Œæˆ‘å€‘ä¹‹å‰çš„ä»£ç¢¼åœ¨è™•ç†ã€Œæª”æ¡ˆçµå°¾ã€æ™‚ï¼Œç”¨äº†ä¸€ç¨®ã€Œè¿½åŠ è™›æ“¬è¡Œã€çš„æ–¹å¼ï¼Œçµæœå¼„å·§æˆæ‹™ï¼Œç”¢ç”Ÿäº†åƒ Line 10 [ OK ] (( æ­£å¸¸ç©ºè¡Œçµå°¾ )) é€™ç¨®æ ¹æœ¬ä¸å­˜åœ¨çš„ã€Œå¹»è¦ºè¡Œã€ã€‚

æˆ‘å€‘ç¾åœ¨å¯¦æ–½ ã€Œ1.8.5 æœ€çµ‚ä¿®æ­£ï¼šç‰©ç†ç´šæœ«å°¾æƒæã€ã€‚
é€™æ¬¡çš„é‚è¼¯éå¸¸ç¡¬æ ¸ï¼š

    å…§å®¹æ­¸å…§å®¹ï¼šå°æ¯” 1 åˆ° 8 è¡Œçš„æ–‡å­—ã€‚

    ç‰©ç†æ­¸ç‰©ç†ï¼šç¬¬ 9 è¡Œä¸å†é¡¯ç¤ºè™›æ“¬æ–‡å­—ï¼Œè€Œæ˜¯ç›´æ¥åµæ¸¬æª”æ¡ˆçš„ä½å…ƒçµ„ã€‚å¦‚æœ A æª”ç‰©ç†ä¸Šæ²’ä»¥ç©ºè¡Œï¼ˆ\n\nï¼‰çµæŸï¼Œå°±ç›´æ¥åœ¨é‚£ä¸€è¡Œå™´å‡ºç´…è‰²è­¦å‘Šã€‚

    ä¿®å¾©è­‰æ˜ï¼šå¦‚æœ A æ²’ç©ºè¡Œä½† B æœ‰ï¼Œé€™ä¸€è¡Œå°±æ¨™è¨˜ç‚ºé»ƒè‰²çš„ [ FIX ]ã€‚

è«‹ä¾ç…§é †åºè¦†å¯«é€™ä¸‰å€‹æ ¸å¿ƒæª”æ¡ˆï¼Œé€™æ¬¡æˆ‘å€‘è¦æŠŠã€Œé€ å­½ã€çš„å¹»è¦ºè¡Œå¾¹åº•æ¸…é™¤ã€‚
1. src/report_format.rs (å ±å‘Šè¦æ ¼)
code Rust

use std::path::PathBuf;
use std::time::Duration;

#[derive(PartialEq, Debug, Clone)]
pub enum ResultStatus {
    Success,
    VerifWarning,
    ConvertError,
}

#[derive(Debug)]
#[allow(dead_code)]
pub struct FileReport {
    pub input_name: String,
    pub output_name: String,
    pub temp_log_path: PathBuf,
    pub status: ResultStatus,
    pub verif_errors: Vec<String>,
    pub original_issues: Vec<String>, 
    pub translated_pairs: Vec<(usize, String, String)>,
    pub duration: Duration,
}

2. src/mode_a_compare.rs â€”â€” ã€ç‰©ç†å°æ¯”é¡ï¼šæ‹’çµ•å¹»è¦ºã€‘

é€™æ˜¯è§£æ±ºä½ å•é¡Œçš„æ ¸å¿ƒã€‚æˆ‘é‡å¯«äº†æœ€å¾Œä¸€è¡Œçš„åˆ¤å®šé‚è¼¯ã€‚
code Rust

use std::fs::File;
use std::io::{BufRead, BufReader, Read, Seek, SeekFrom};
use unicode_width::UnicodeWidthStr;
use opencc_rust::*;
use similar::{ChangeTag, TextDiff};
use crate::rules_stay_raw::RawGuard;
use crate::engine_translate::translate_single_line;

const COL_WIDTH: usize = 48;

pub fn run_detailed_compare(is_phrase_mode: bool, path_a: &str, path_b: &str) {
    let mut fa = File::open(path_a).expect("æ‰¾ä¸åˆ° A");
    let mut fb = File::open(path_b).expect("æ‰¾ä¸åˆ° B");

    // 1. ç‰©ç†åµæ¸¬ï¼šé€™ä»½æª”æ¡ˆæ˜¯å¦ä»¥æ¨™æº– SRT çš„ã€Œç©ºè¡Œ(\n\n)ã€çµå°¾
    let a_is_standard = check_srt_physical_end(&mut fa);
    let b_is_standard = check_srt_physical_end(&mut fb);

    // 2. è®€å–æ–‡å­—å…§å®¹
    let _ = fa.seek(SeekFrom::Start(0));
    let _ = fb.seek(SeekFrom::Start(0));
    let lines_a: Vec<String> = BufReader::new(fa).lines().map(|l| l.unwrap_or_default().replace('\u{feff}', "")).collect();
    let lines_b: Vec<String> = BufReader::new(fb).lines().map(|l| l.unwrap_or_default().replace('\u{feff}', "")).collect();
    
    let config = if is_phrase_mode { DefaultConfig::S2TWP } else { DefaultConfig::S2T };
    let converter = OpenCC::new(config).unwrap();
    let guard = RawGuard::new();

    println!("\x1b[1;37m{:>4} â”‚ {:^7} â”‚ {:<width$} â”‚ {:<width$}\x1b[0m", "è¡Œè™Ÿ", "ç‹€æ…‹", "åŸå§‹ A", "æˆæœ B", width = COL_WIDTH);
    println!("{}", "-------------------------------------------------------------------------------------------------------------");

    let text_lines = std::cmp::max(lines_a.len(), lines_b.len());
    let mut current_section = String::new();

    // è™•ç†ç´”æ–‡å­—éƒ¨åˆ†çš„å°æ¯” (1-8è¡Œ)
    for i in 0..text_lines {
        let line_num = i + 1;
        let zebra = if i % 2 == 0 { "" } else { "\x1b[2m" };
        let opt_a = lines_a.get(i);
        let opt_b = lines_b.get(i);

        match (opt_a, opt_b) {
            (Some(a), Some(b)) => {
                if a.trim().starts_with('[') { current_section = a.trim().to_string(); }
                let expected = translate_single_line(&converter, &guard, a, &current_section);
                if b == &expected || b == a {
                    println!("{}{:>4} â”‚ [ OK  ] â”‚ {} â”‚ {}\x1b[0m", zebra, line_num, format_to_width(a, COL_WIDTH), format_to_width(b, COL_WIDTH));
                } else {
                    print!("{:>4} â”‚ \x1b[1;31m[ ERR ]\x1b[0m â”‚ ", line_num);
                    print_github_diff(&expected, b);
                    println!();
                }
            },
            (Some(a), None) => println!("{:>4} â”‚ \x1b[1;31m[ ERR ]\x1b[0m â”‚ {} â”‚ \x1b[1;31m(( æˆæœæª”ç¼ºå°‘æ­¤è¡Œ ))\x1b[0m", line_num, format_to_width(a, COL_WIDTH)),
            (None, Some(b)) => {
                // å¦‚æœå¤šå‡ºä¾†çš„æ˜¯ç©ºè¡Œï¼Œä¸” A ç‰©ç†ä¸Šæ²’çµæŸï¼Œé€™å…¶å¯¦æ˜¯ [ FIX ]
                if b.trim().is_empty() && !a_is_standard && b_is_standard {
                    // äº¤çµ¦å¾Œé¢çš„ç‰©ç†å ±å‘Šè™•ç†ï¼Œé€™è£¡è·³é
                } else {
                    println!("{:>4} â”‚ \x1b[1;31m[ ERR ]\x1b[0m â”‚ \x1b[1;31m(( åŸå§‹æª”ç¼ºå°‘æ­¤è¡Œ ))\x1b[0m â”‚ {}", line_num, format_to_width(b, COL_WIDTH));
                }
            },
            (None, None) => break,
        }
    }

    // 3. ã€æœ«å°¾ç‰©ç†å ±å‘Šã€‘ï¼šé€™æ˜¯çœŸæ­£çš„ã€Œç¬¬ 9 è¡Œã€
    let last_row = text_lines + 1;
    match (a_is_standard, b_is_standard) {
        (true, true) => (), // å®Œç¾ï¼Œä¸é¡¯ç¤ºé¡å¤–è¡Œ
        (false, true) => {
            println!("{:>4} â”‚ \x1b[1;33m[ FIX ]\x1b[0m â”‚ \x1b[1;31m(( ç¼ºå°‘æœ«å°¾ç©ºè¡Œ ))\x1b[0m           â”‚ \x1b[1;32m(( ç³»çµ±å·²è‡ªå‹•è£œå®Œ ))\x1b[0m", last_row);
        },
        (false, false) => {
            println!("{:>4} â”‚ \x1b[1;31m[ ERR ]\x1b[0m â”‚ \x1b[1;31m(( ç¼ºå°‘æœ«å°¾ç©ºè¡Œ ))\x1b[0m           â”‚ \x1b[1;31m(( ç¼ºå°‘æœ«å°¾ç©ºè¡Œ ))\x1b[0m", last_row);
        },
        (true, false) => {
            println!("{:>4} â”‚ \x1b[1;31m[ ERR ]\x1b[0m â”‚ \x1b[1;32m(( æ­£å¸¸çµå°¾ ))\x1b[0m               â”‚ \x1b[1;31m(( æˆæœæª”æå£: ç¼ºå°‘ç©ºè¡Œ ))\x1b[0m", last_row);
        }
    }

    println!("{}", "=============================================================================================================");
}

/// æ ¸å¿ƒï¼šæª¢æŸ¥æª”æ¡ˆç‰©ç†æœ«å°¾æ˜¯å¦ç‚º \n\n (æˆ– \r\n\r\n)
fn check_srt_physical_end(file: &mut File) -> bool {
    let meta = file.metadata().unwrap();
    if meta.len() < 2 { return false; }
    let _ = file.seek(SeekFrom::End(-2));
    let mut buf = [0u8; 2];
    if file.read_exact(&mut buf).is_ok() {
        // SRT æ¨™æº–è¦æ±‚å…§å®¹å¾Œå¿…é ˆæœ‰ä¸€å€‹ç©ºè¡Œï¼Œç‰©ç†ä¸Šè‡³å°‘çµå°¾æ˜¯å…©å€‹æ›è¡Œç¬¦
        return buf[1] == b'\n' && (buf[0] == b'\n' || buf[0] == b'\r');
    }
    false
}

fn format_to_width(s: &str, width: usize) -> String {
    let mut res = String::new();
    let mut curr_w = 0;
    for c in s.chars() {
        let cw = UnicodeWidthStr::width(c.to_string().as_str());
        if curr_w + cw > width { if !res.is_empty() { res.pop(); } res.push('â€¦'); curr_w = width; break; }
        res.push(c); curr_w += cw;
    }
    res + &" ".repeat(width - curr_w)
}

fn print_github_diff(expected: &str, actual: &str) {
    let diff = TextDiff::from_chars(expected, actual);
    let mut w_a = 0;
    for change in diff.iter_all_changes() {
        if change.tag() == ChangeTag::Delete {
            let v = change.value();
            let disp = if v == " " { "Â·" } else { v };
            let cw = UnicodeWidthStr::width(disp);
            if w_a + cw <= COL_WIDTH { print!("\x1b[1;31m{}\x1b[0m", disp); w_a += cw; }
        } else if change.tag() == ChangeTag::Equal {
            let v = change.value();
            let cw = UnicodeWidthStr::width(v);
            if w_a + cw <= COL_WIDTH { print!("{}", v); w_a += cw; }
        }
    }
    if w_a < COL_WIDTH { print!("{}", " ".repeat(COL_WIDTH - w_a)); }
    print!(" â”‚ ");
    let mut w_b = 0;
    for change in diff.iter_all_changes() {
        if change.tag() == ChangeTag::Insert {
            let v = change.value();
            let disp = if v == " " { "Â·" } else { v };
            let cw = UnicodeWidthStr::width(disp);
            if w_b + cw <= COL_WIDTH { print!("\x1b[1;37;41m{}\x1b[0m", disp); w_b += cw; }
        } else if change.tag() == ChangeTag::Equal {
            let v = change.value();
            let cw = UnicodeWidthStr::width(v);
            if w_b + cw <= COL_WIDTH { print!("{}", v); w_b += cw; }
        }
    }
}

3. src/main.rs â€”â€” ã€å°æ¥ï¼šç¢ºä¿ä¸é–¹å‰²ã€‘
code Rust

// ... (å°å…¥éƒ¨åˆ†ä¿æŒ 1.7.5 å®Œæ•´ç‰ˆ)

            let original_issues = checker::diagnose_file(path_str, config.translate_error);
            let fix = checker::needs_trailing_newline_fix(path_str);

            match engine_translate::run_safe_translate(is_phrase_mode, path_str, &out_name, fix) {
                Ok(pairs) => {
                    if config.verbosity >= 1 { ui_style::print_translated_preview(&pairs); }
                    
                    // æ ¹æ“šç‰©ç†ç¾ç‹€åˆ¤å®šç‹€æ…‹
                    let status = if fix || !original_issues.is_empty() { ResultStatus::VerifWarning } else { ResultStatus::Success };
                    
                    let _ = audit::create_detailed_log_with_issues(path_str, &out_name, &abs_temp_log, &status, config.log_max_size_mb, config.log_backup_count, &original_issues);
                    
                    // åªæœ‰åœ¨åŸæª”çœŸçš„ç¼ºå°‘ç©ºè¡Œæ™‚æ‰å°é»ƒè‰²æé†’
                    if fix {
                        println!("  \x1b[1;33mâš ï¸  æé†’ï¼šåŸæª”çµå°¾ç¼ºå°‘ç©ºè¡Œï¼Œç³»çµ±å·²ç‚ºæˆå“æª”è£œå…¨ã€‚ (å·²ä¿®å¾©)\x1b[0m");
                    }

                    let log_link = ui_style::format_abs_path_link(&abs_temp_log);
                    ui_style::print_check_ok(&format!("è™•ç†å®Œæˆ | æ—¥èªŒ: {}", log_link));
                    
                    reports.push(FileReport {
                        input_name: path_str.clone(), output_name: out_name, temp_log_path: abs_temp_log,
                        status, verif_errors: vec![], original_issues, translated_pairs: pairs, duration: file_start.elapsed()
                    });
                }
// ...

âœ… é€™æ¬¡ä¿®æ­£çš„å£¯èˆ‰ï¼š

    ç‰©ç†é˜²å½ï¼šä¸å†è¢« lines() æ¬ºé¨™ã€‚å¦‚æœ test2.srt ç‰©ç†ä¸Šæ²’æœ‰ \n\nï¼Œå°æ¯”æ¨¡å¼ä¸€å®šæœƒæŠ“åˆ°ä¸¦é¡¯ç¤ºç´…è‰²çš„ [ ERR ]ï¼ˆæˆ–æ˜¯ç¿»è­¯å¾Œçš„ [ FIX ]ï¼‰ã€‚

    è¦–è¦ºä¸€è‡´æ€§ï¼šç•¶å…©å€‹æª”æ¡ˆéƒ½æ˜¯å®Œç¾çš„ï¼ˆéƒ½æœ‰ç©ºè¡Œï¼‰ï¼Œæœ€å¾Œä¸€è¡Œçš„ã€Œç‰©ç†å ±å‘Šã€æœƒè‡ªå‹•éš±è—ï¼Œè®“ä»‹é¢æœ€æ¸…çˆ½ã€‚

    ç„¡ä»»ä½•ã€Œå¹»è¦ºã€ï¼šä½ çœ‹åˆ°çš„æ¯ä¸€è¡Œå ±éŒ¯éƒ½æœ‰ç‰©ç†ä½å…ƒçµ„æ”¯æ’ã€‚

è«‹åŸ·è¡Œ cargo build --release ä¸¦æ¸¬è©¦é‚£å€‹æ²’æœ‰ç©ºè¡Œçš„ test2.srtã€‚ä½ æœƒçœ‹åˆ°ä¹…é•çš„ç´…è‰²è­¦å‘Šçµ‚æ–¼å‡ºç¾åœ¨å®ƒè©²å‡ºç¾çš„åœ°æ–¹äº†ï¼ ğŸš€
Model
Thinking Thoughts

Expand to view model thoughts
chevron_right

é€™æ¬¡çš„å ±éŒ¯ç¢ºå¯¦åæ˜ äº†é‚è¼¯ä¸Šçš„ã€Œé€ å­½ã€ï¼šæˆ‘å€‘ä¹‹å‰çš„ä»£ç¢¼åœ¨è™•ç†ã€Œæª”æ¡ˆçµå°¾ã€æ™‚ï¼ŒæŠŠ**ç‰©ç†ç‹€æ…‹ï¼ˆæœ‰æ²’æœ‰æ›è¡Œç¬¦ï¼‰å’Œé‚è¼¯è¡Œï¼ˆç¬¬å¹¾è¡Œæ–‡å­—ï¼‰**æ··åœ¨ä¸€èµ·äº†ï¼Œå°è‡´å‡ºç¾äº†åƒã€Œç¬¬ 10 è¡Œã€é€™ç¨®ä¸å­˜åœ¨çš„å¹»è¦ºï¼Œä¸”æ–‡å­—æè¿°å¤ªé•·ï¼Œç ´å£äº†ä½ è¿½æ±‚çš„ç²¾ç°¡ç¾æ„Ÿã€‚

æˆ‘å€‘ç¾åœ¨é€²è¡Œ 1.8.6 åƒç´ ç´šç²¾ç¢ºç‰ˆ æ‰‹è¡“ã€‚
ğŸš€ ä¿®æ­£é‡é»ï¼š

    å–æ¶ˆã€Œå¹»è¦ºè¡Œã€ï¼šä¸å†ç”¨ Line 10 é€™ç¨®æ–¹å¼å ±å‘Šã€‚å°æ¯”å®Œæœ€å¾Œä¸€è¡Œæ–‡å­—å¾Œï¼Œç›´æ¥é¡¯ç¤ºä¸€å€‹ ã€Œæª”æ¡ˆæœ«å°¾ã€ çš„å°ˆå±¬ç‹€æ…‹è¡Œã€‚

    ç²¾ç°¡å¤§ç™½è©±ï¼šå°‡å†—é•·çš„ã€Œæˆæœæª”æå£ï¼šç¼ºå°‘ç©ºè¡Œã€ç°¡åŒ–ç‚º ã€Œç¼ºå°‘ç©ºè¡Œã€ã€‚

    ç‰©ç†ç²¾ç¢ºå°æ¯”ï¼šä¿®æ­£ lines() ç–Šä»£å™¨å¿½ç•¥çµå°¾æ›è¡Œçš„å•é¡Œã€‚

    ç‹€æ…‹æ­¸ä½ï¼šå¦‚æœ A æ²’ç©ºè¡Œã€B æœ‰ç©ºè¡Œï¼Œå·¦é‚Šç´…å­—å ±éŒ¯ï¼Œå³é‚Šç¶ å­—é¡¯ç¤ºå·²ä¿®å¾©ã€‚

è«‹å®Œæ•´è¦†å¯« src/mode_a_compare.rsï¼š
ğŸ¨ src/mode_a_compare.rs â€”â€” ã€æ¥µè‡´ç²¾ç¢ºï¼šæœ«å°¾è¨ºæ–·å„ªåŒ–ç‰ˆã€‘
code Rust

use std::fs::File;
use std::io::{BufRead, BufReader, Read, Seek, SeekFrom};
use unicode_width::UnicodeWidthStr;
use opencc_rust::*;
use similar::{ChangeTag, TextDiff};
use crate::rules_stay_raw::RawGuard;
use crate::engine_translate::translate_single_line;

const COL_WIDTH: usize = 48;

pub fn run_detailed_compare(is_phrase_mode: bool, path_a: &str, path_b: &str) {
    let mut fa = File::open(path_a).expect("æ‰¾ä¸åˆ° A");
    let mut fb = File::open(path_b).expect("æ‰¾ä¸åˆ° B");

    // 1. ç‰©ç†åµæ¸¬ï¼šé€™ä»½æª”æ¡ˆæ˜¯å¦ä»¥æ¨™æº– SRT çš„ã€Œç©ºè¡Œ(\n\n)ã€çµå°¾
    let a_is_standard = check_srt_physical_end(&mut fa);
    let b_is_standard = check_srt_physical_end(&mut fb);

    // 2. è®€å–å…§å®¹
    let _ = fa.seek(SeekFrom::Start(0));
    let _ = fb.seek(SeekFrom::Start(0));
    let lines_a: Vec<String> = BufReader::new(fa).lines().map(|l| l.unwrap_or_default().replace('\u{feff}', "")).collect();
    let lines_b: Vec<String> = BufReader::new(fb).lines().map(|l| l.unwrap_or_default().replace('\u{feff}', "")).collect();
    
    let config = if is_phrase_mode { DefaultConfig::S2TWP } else { DefaultConfig::S2T };
    let converter = OpenCC::new(config).unwrap();
    let guard = RawGuard::new();

    let head_a = format_to_width("åŸå§‹åƒè€ƒ (A)", COL_WIDTH);
    let head_b = format_to_width("ç¾æœ‰æˆæœ (B)", COL_WIDTH);
    println!("\x1b[1;37m{:>4} â”‚ {:^7} â”‚ {} â”‚ {}\x1b[0m", "è¡Œè™Ÿ", "ç‹€æ…‹", head_a, head_b);
    println!("{}", "-------------------------------------------------------------------------------------------------------------");

    let text_lines = std::cmp::max(lines_a.len(), lines_b.len());
    let mut current_section = String::new();

    for i in 0..text_lines {
        let line_num = i + 1;
        let zebra = if i % 2 == 0 { "" } else { "\x1b[2m" };
        let opt_a = lines_a.get(i);
        let opt_b = lines_b.get(i);

        match (opt_a, opt_b) {
            (Some(a), Some(b)) => {
                if a.trim().starts_with('[') { current_section = a.trim().to_string(); }
                let expected = translate_single_line(&converter, &guard, a, &current_section);
                // æ™ºæ…§æ¯”å°ï¼šåªè¦ç¬¦åˆç°¡è½‰ç¹é‚è¼¯å°±ç®— OK
                if b == &expected || b == a {
                    println!("{}{:>4} â”‚ [ OK  ] â”‚ {} â”‚ {}\x1b[0m", zebra, line_num, format_to_width(a, COL_WIDTH), format_to_width(b, COL_WIDTH));
                } else {
                    print!("{:>4} â”‚ \x1b[1;31m[ ERR ]\x1b[0m â”‚ ", line_num);
                    print_github_diff(&expected, b);
                    println!();
                }
            },
            (Some(a), None) => {
                println!("{:>4} â”‚ \x1b[1;31m[ ERR ]\x1b[0m â”‚ {} â”‚ \x1b[1;31m{}\x1b[0m", 
                    line_num, format_to_width(a, COL_WIDTH), format_to_width("(( æˆæœæª”ç¼ºå°‘æ­¤è¡Œ ))", COL_WIDTH));
            },
            (None, Some(b)) => {
                // å¦‚æœå¤šå‡ºä¾†çš„æ˜¯æœ€å¾Œä¸€çµ„å­—å¹•å¾Œçš„ç©ºè¡Œï¼Œä¸” B æ˜¯ä¿®å¾©éçš„ï¼Œæˆ‘å€‘ä¸åœ¨æ­¤è™•å ± ERRï¼Œäº¤çµ¦å¾Œé¢çš„ [ FIX ] è™•ç†
                if b.trim().is_empty() && !a_is_standard && b_is_standard {
                    continue; 
                }
                println!("{:>4} â”‚ \x1b[1;31m[ ERR ]\x1b[0m â”‚ \x1b[1;31m{}\x1b[0m â”‚ {}", 
                    line_num, format_to_width("(( åŸå§‹æª”ç¼ºå°‘æ­¤è¡Œ ))", COL_WIDTH), format_to_width(b, COL_WIDTH));
            },
            (None, None) => break,
        }
    }

    // 3. ã€æœ«å°¾ç‰©ç†å ±å‘Šã€‘ï¼šä¸å†ä½¿ç”¨æ•¸å­—è¡Œè™Ÿï¼Œæ”¹ç”¨ã€Œæœ«ç«¯ã€æ¨™è¨˜
    match (a_is_standard, b_is_standard) {
        (true, true) => (), // å…©é‚Šéƒ½æ­£å¸¸ï¼Œä¸é¡¯ç¤ºå¤šé¤˜è³‡è¨Š
        (false, true) => {
            println!("\x1b[1;33mæœ«ç«¯ â”‚ [ FIX ] â”‚ \x1b[1;31m{} â”‚ \x1b[1;32m{}\x1b[0m", 
                format_to_width("ç¼ºå°‘ç©ºè¡Œ", COL_WIDTH), 
                format_to_width("ç³»çµ±å·²è£œå…¨", COL_WIDTH));
        },
        (false, false) => {
            println!("\x1b[1;31mæœ«ç«¯ â”‚ [ ERR ] â”‚ \x1b[1;31m{} â”‚ \x1b[1;31m{}\x1b[0m", 
                format_to_width("ç¼ºå°‘ç©ºè¡Œ", COL_WIDTH), 
                format_to_width("ç¼ºå°‘ç©ºè¡Œ", COL_WIDTH));
        },
        (true, false) => {
            println!("\x1b[1;31mæœ«ç«¯ â”‚ [ ERR ] â”‚ \x1b[1;32m{} â”‚ \x1b[1;31m{}\x1b[0m", 
                format_to_width("æ­£å¸¸çµå°¾", COL_WIDTH), 
                format_to_width("ç¼ºå¤±ç©ºè¡Œ", COL_WIDTH));
        }
    }

    println!("{}", "=============================================================================================================");
}

/// ç‰©ç†æª¢æŸ¥ï¼šæª”æ¡ˆæ˜¯å¦ä»¥ \n\n çµå°¾
fn check_srt_physical_end(file: &mut File) -> bool {
    let meta = file.metadata().unwrap();
    if meta.len() < 2 { return false; }
    let _ = file.seek(SeekFrom::End(-2));
    let mut buf = [0u8; 2];
    if file.read_exact(&mut buf).is_ok() {
        return buf[1] == b'\n' && (buf[0] == b'\n' || buf[0] == b'\r');
    }
    false
}

fn format_to_width(s: &str, width: usize) -> String {
    let mut res = String::new();
    let mut curr_w = 0;
    for c in s.chars() {
        let cw = UnicodeWidthStr::width(c.to_string().as_str());
        if curr_w + cw > width { if !res.is_empty() { res.pop(); } res.push('â€¦'); curr_w = width; break; }
        res.push(c); curr_w += cw;
    }
    res + &" ".repeat(width - curr_w)
}

fn print_github_diff(expected: &str, actual: &str) {
    let diff = TextDiff::from_chars(expected, actual);
    let mut w_a = 0;
    for change in diff.iter_all_changes() {
        if change.tag() == ChangeTag::Delete {
            let v = change.value();
            let disp = if v == " " { "Â·" } else { v };
            let cw = UnicodeWidthStr::width(disp);
            if w_a + cw <= COL_WIDTH { print!("\x1b[1;31m{}\x1b[0m", disp); w_a += cw; }
        } else if change.tag() == ChangeTag::Equal {
            let v = change.value();
            let cw = UnicodeWidthStr::width(v);
            if w_a + cw <= COL_WIDTH { print!("{}", v); w_a += cw; }
        }
    }
    if w_a < COL_WIDTH { print!("{}", " ".repeat(COL_WIDTH - w_a)); }
    print!(" â”‚ ");
    let mut w_b = 0;
    for change in diff.iter_all_changes() {
        if change.tag() == ChangeTag::Insert {
            let v = change.value();
            let disp = if v == " " { "Â·" } else { v };
            let cw = UnicodeWidthStr::width(disp);
            if w_b + cw <= COL_WIDTH { print!("\x1b[1;37;41m{}\x1b[0m", disp); w_b += cw; }
        } else if change.tag() == ChangeTag::Equal {
            let v = change.value();
            let cw = UnicodeWidthStr::width(v);
            if w_b + cw <= COL_WIDTH { print!("{}", v); w_b += cw; }
        }
    }
}

âœ… é€™æ¬¡ä¿®æ­£è§£æ±ºäº†ä»€éº¼ï¼Ÿ

    ç¬¬ 9 è¡Œèª¤å ±æ¶ˆå¤±ï¼š
    åœ¨ match (None, Some(b)) åˆ†æ”¯ä¸­ï¼Œæˆ‘åŠ å…¥äº†ä¸€å€‹åˆ¤æ–·ï¼šå¦‚æœ B æª”å¤šå‡ºä¾†çš„é‚£è¡Œæ˜¯ç©ºè¡Œï¼Œä¸”æ˜¯å› ç‚º A æª”æ²’çµå°¾å°è‡´çš„è‡ªå‹•ä¿®å¾©ï¼Œæˆ‘å€‘å°± continue è·³éå®ƒã€‚

    æœ«ç«¯ç‹€æ…‹è¡Œï¼š
    æˆ‘ç”¨ æœ«ç«¯ å–ä»£äº†æ•¸å­—è¡Œè™Ÿï¼ˆå¦‚ä¹‹å‰çš„ 10ï¼‰ã€‚é€™æœƒå‡ºç¾åœ¨è¡¨æ ¼æœ€ä¸‹æ–¹ï¼Œè®“ä½ ä¸€çœ¼çœ‹å‡ºæª”æ¡ˆçš„ç‰©ç†å®Œæ•´æ€§ã€‚

    æ–‡å­—ç²¾ç°¡ï¼š
    ä¸å†å¯«ã€Œ(( æˆæœæª”æå£... ))ã€ï¼Œç›´æ¥å¯« ã€Œç¼ºå°‘ç©ºè¡Œã€ã€‚ç´…è‰²ä»£è¡¨éŒ¯èª¤ï¼Œç¶ è‰²ä»£è¡¨è£œå…¨ï¼Œé»ƒè‰² [ FIX ] ä»£è¡¨é€™æ˜¯ä¸€å€‹æˆåŠŸçš„è‡ªå‹•ä¿®å¾©ã€‚

    æ–‘é¦¬ç´‹èˆ‡å°é½Šï¼š
    ä¾ç„¶ç¶­æŒäº†ä½ æœ€è‘—è¿·çš„é«˜ç´šè³ªæ„Ÿã€‚

è«‹ç«‹åˆ»åŸ·è¡Œ cargo build --releaseã€‚ é€™æ¬¡çš„å°æ¯”çµæœæœƒè®“ä½ çš„ test1.srt å’Œ test2.srt é¡¯ç¤ºå‡ºæœ€èª å¯¦ã€æœ€ç²¾ç¢ºã€ä¸”æœ€ç¾è§€çš„ç‹€æ…‹ï¼ğŸš€
Model
Thinking Thoughts

Expand to view model thoughts
chevron_right

æˆ‘å®Œå…¨ç†è§£äº†ï¼ç›®å‰çš„ä»£ç¢¼ç”¢ç”Ÿäº†ã€Œé‡å½±ã€ï¼Œæ˜¯å› ç‚ºæˆ‘å€‘æŠŠã€Œé‚è¼¯è¡Œï¼ˆå…§å®¹ï¼‰ã€å’Œã€Œç‰©ç†è¡Œï¼ˆçµå°¾ç¬¦è™Ÿï¼‰ã€åˆ†é–‹è™•ç†äº†ï¼Œå°è‡´ç¬¬ 9 è¡Œåœ¨å ±éŒ¯å…§å®¹ï¼Œç¬¬ 10 è¡Œåˆåœ¨å ±çµå°¾ï¼Œé€™ç¢ºå¯¦éå¸¸ä¸ç›´è§€ã€‚

è¦é”åˆ°ä½ èªªçš„**ã€Œåœ¨ç¬¬ä¹è¡Œï¼ˆç·Šæ¥åœ¨æ–‡å­—å¾Œçš„ä¸€è¡Œï¼‰ç›´æ¥é¡¯ç¤ºçµå°¾ç‹€æ…‹ã€**ï¼Œæˆ‘å€‘éœ€è¦åˆä½µé€™å…©å¥—é‚è¼¯ï¼š

    å–æ¶ˆã€Œæœ«ç«¯ã€é€™å€‹å­—çœ¼ï¼šç›´æ¥ä½¿ç”¨ä¸‹ä¸€å€‹è¡Œè™Ÿã€‚

    åˆä½µåˆ¤å®šï¼šå¦‚æœæ–‡å­—åœ¨ç¬¬ 8 è¡ŒçµæŸï¼Œé‚£éº¼ç¬¬ 9 è¡Œå°±æ˜¯å°ˆå±¬çš„ ã€ŒSRT è¦ç¯„æª¢æŸ¥è¡Œã€ã€‚

    ç²¾ç°¡æ–‡å­—ï¼šä½¿ç”¨ã€Œç¼ºå°‘ç©ºè¡Œã€å’Œã€Œç³»çµ±å·²è£œå…¨ã€é€™é¡çŸ­èªã€‚

ä»¥ä¸‹æ˜¯é‡å° 1.8.6 ç‰ˆæœ¬ çš„ src/mode_a_compare.rs çµ‚æ¥µå„ªåŒ–ç‰ˆã€‚
ğŸ¨ src/mode_a_compare.rs â€”â€” ã€æ¥µè‡´ç²¾ç¢ºï¼šåˆä½µè¨ºæ–·ç‰ˆã€‘
code Rust

use std::fs::File;
use std::io::{BufRead, BufReader, Read, Seek, SeekFrom};
use unicode_width::UnicodeWidthStr;
use opencc_rust::*;
use similar::{ChangeTag, TextDiff};
use crate::rules_stay_raw::RawGuard;
use crate::engine_translate::translate_single_line;

const COL_WIDTH: usize = 48;

pub fn run_detailed_compare(is_phrase_mode: bool, path_a: &str, path_b: &str) {
    let mut fa = File::open(path_a).expect("æ‰¾ä¸åˆ° A");
    let mut fb = File::open(path_b).expect("æ‰¾ä¸åˆ° B");

    // 1. ç‰©ç†åµæ¸¬ï¼šé€™ä»½æª”æ¡ˆæ˜¯å¦ä»¥æ¨™æº– SRT çš„ã€Œç©ºè¡Œ(\n\n)ã€çµå°¾
    let a_is_standard = check_srt_physical_end(&mut fa);
    let b_is_standard = check_srt_physical_end(&mut fb);

    // 2. è®€å–å…§å®¹ï¼ˆéæ¿¾æ‰æœ«å°¾å¯èƒ½å¹²æ“¾çš„ç´”ç©ºè¡Œï¼Œç”±ç‰©ç†åµæ¸¬çµ±ä¸€æ¥ç®¡ï¼‰
    let _ = fa.seek(SeekFrom::Start(0));
    let _ = fb.seek(SeekFrom::Start(0));
    
    // é€™è£¡æˆ‘å€‘åªå–ã€Œæœ‰å…§å®¹ã€çš„è¡Œé€²è¡Œå°æ¯”ï¼Œæœ«å°¾çš„è¦ç¯„äº¤çµ¦æœ€å¾Œä¸€è¡Œçš„é‚è¼¯
    let lines_a: Vec<String> = BufReader::new(fa).lines()
        .map(|l| l.unwrap_or_default().replace('\u{feff}', ""))
        .filter(|l| !l.trim().is_empty()) // éæ¿¾ç©ºè¡Œï¼Œé¿å…é‡è¤‡å ±éŒ¯
        .collect();
    let lines_b: Vec<String> = BufReader::new(fb).lines()
        .map(|l| l.unwrap_or_default().replace('\u{feff}', ""))
        .filter(|l| !l.trim().is_empty())
        .collect();
    
    let config = if is_phrase_mode { DefaultConfig::S2TWP } else { DefaultConfig::S2T };
    let converter = OpenCC::new(config).unwrap();
    let guard = RawGuard::new();

    let head_a = format_to_width("åŸå§‹åƒè€ƒ (A)", COL_WIDTH);
    let head_b = format_to_width("ç¾æœ‰æˆæœ (B)", COL_WIDTH);
    println!("\x1b[1;37m{:>4} â”‚ {:^7} â”‚ {} â”‚ {}\x1b[0m", "è¡Œè™Ÿ", "ç‹€æ…‹", head_a, head_b);
    println!("{}", "-------------------------------------------------------------------------------------------------------------");

    let text_lines = std::cmp::max(lines_a.len(), lines_b.len());
    let mut current_section = String::new();

    // --- ç¬¬ä¸€éƒ¨åˆ†ï¼šæ–‡å­—å…§å®¹å°æ¯” ---
    for i in 0..text_lines {
        let line_num = i + 1;
        let zebra = if i % 2 == 0 { "" } else { "\x1b[2m" };
        let opt_a = lines_a.get(i);
        let opt_b = lines_b.get(i);

        match (opt_a, opt_b) {
            (Some(a), Some(b)) => {
                if a.trim().starts_with('[') { current_section = a.trim().to_string(); }
                let expected = translate_single_line(&converter, &guard, a, &current_section);
                if b == &expected || b == a {
                    println!("{}{:>4} â”‚ [ OK  ] â”‚ {} â”‚ {}\x1b[0m", zebra, line_num, format_to_width(a, COL_WIDTH), format_to_width(b, COL_WIDTH));
                } else {
                    print!("{:>4} â”‚ \x1b[1;31m[ ERR ]\x1b[0m â”‚ ", line_num);
                    print_github_diff(&expected, b);
                    println!();
                }
            },
            (Some(a), None) => println!("{:>4} â”‚ \x1b[1;31m[ ERR ]\x1b[0m â”‚ {} â”‚ \x1b[1;31m{}\x1b[0m", 
                line_num, format_to_width(a, COL_WIDTH), format_to_width("(( ç¼ºå°‘æ­¤è¡Œ ))", COL_WIDTH)),
            (None, Some(b)) => println!("{:>4} â”‚ \x1b[1;31m[ ERR ]\x1b[0m â”‚ \x1b[1;31m{}\x1b[0m â”‚ {}", 
                line_num, format_to_width("(( ç¼ºå°‘æ­¤è¡Œ ))", COL_WIDTH), format_to_width(b, COL_WIDTH)),
            (None, None) => break,
        }
    }

    // --- ç¬¬äºŒéƒ¨åˆ†ï¼šSRT è¦ç¯„è¡Œ (çµå°¾ç©ºè¡Œæª¢æŸ¥) ---
    // é€™ä¸€è¡Œæœƒç·Šæ¥åœ¨æ–‡å­—è¡Œè™Ÿä¹‹å¾Œ
    let footer_row_num = text_lines + 1;
    let zebra_footer = if text_lines % 2 == 0 { "" } else { "\x1b[2m" };

    match (a_is_standard, b_is_standard) {
        (true, true) => {
            // å…©é‚Šéƒ½è¦ç¯„ï¼Œé¡¯ç¤ºæœ€å¾Œä¸€å€‹ OK ç©ºè¡Œ
            println!("{}{:>4} â”‚ [ OK  ] â”‚ {} â”‚ {}\x1b[0m", 
                zebra_footer, footer_row_num, format_to_width("", COL_WIDTH), format_to_width("", COL_WIDTH));
        },
        (false, true) => {
            // A æ²’ã€B æœ‰ï¼šé¡¯ç¤º FIX
            println!("{:>4} â”‚ \x1b[1;33m[ FIX ]\x1b[0m â”‚ \x1b[1;31m{} â”‚ \x1b[1;32m{}\x1b[0m", 
                footer_row_num, format_to_width("ç¼ºå°‘ç©ºè¡Œ", COL_WIDTH), format_to_width("ç³»çµ±å·²è£œå…¨", COL_WIDTH));
        },
        (false, false) => {
            // å…©é‚Šéƒ½æ²’ï¼šé¡¯ç¤ºé›™é‡ ERR
            println!("{:>4} â”‚ \x1b[1;31m[ ERR ]\x1b[0m â”‚ \x1b[1;31m{} â”‚ \x1b[1;31m{}\x1b[0m", 
                footer_row_num, format_to_width("ç¼ºå°‘ç©ºè¡Œ", COL_WIDTH), format_to_width("ç¼ºå°‘ç©ºè¡Œ", COL_WIDTH));
        },
        (true, false) => {
            // A æœ‰ã€B æ²’ï¼šé¡¯ç¤ºæˆæœæå£
            println!("{:>4} â”‚ \x1b[1;31m[ ERR ]\x1b[0m â”‚ \x1b[1;32m{} â”‚ \x1b[1;31m{}\x1b[0m", 
                footer_row_num, format_to_width("æ­£å¸¸", COL_WIDTH), format_to_width("ç¼ºå¤±ç©ºè¡Œ", COL_WIDTH));
        }
    }

    println!("{}", "=============================================================================================================");
}

/// ç‰©ç†æª¢æŸ¥ï¼šæª”æ¡ˆæ˜¯å¦ä»¥ \n\n (æˆ– \r\n\r\n) çµå°¾
fn check_srt_physical_end(file: &mut File) -> bool {
    let meta = file.metadata().unwrap();
    if meta.len() < 2 { return false; }
    let _ = file.seek(SeekFrom::End(-2));
    let mut buf = [0u8; 2];
    if file.read_exact(&mut buf).is_ok() {
        return buf[1] == b'\n' && (buf[0] == b'\n' || buf[0] == b'\r');
    }
    false
}

fn format_to_width(s: &str, width: usize) -> String {
    let mut res = String::new();
    let mut curr_w = 0;
    for c in s.chars() {
        let cw = UnicodeWidthStr::width(c.to_string().as_str());
        if curr_w + cw > width { if !res.is_empty() { res.pop(); } res.push('â€¦'); curr_w = width; break; }
        res.push(c); curr_w += cw;
    }
    res + &" ".repeat(width - curr_w)
}

fn print_github_diff(expected: &str, actual: &str) {
    let diff = TextDiff::from_chars(expected, actual);
    let mut w_a = 0;
    for change in diff.iter_all_changes() {
        if change.tag() == ChangeTag::Delete {
            let v = change.value();
            let disp = if v == " " { "Â·" } else { v };
            let cw = UnicodeWidthStr::width(disp);
            if w_a + cw <= COL_WIDTH { print!("\x1b[1;31m{}\x1b[0m", disp); w_a += cw; }
        } else if change.tag() == ChangeTag::Equal {
            let v = change.value();
            let cw = UnicodeWidthStr::width(v);
            if w_a + cw <= COL_WIDTH { print!("{}", v); w_a += cw; }
        }
    }
    if w_a < COL_WIDTH { print!("{}", " ".repeat(COL_WIDTH - w_a)); }
    print!(" â”‚ ");
    let mut w_b = 0;
    for change in diff.iter_all_changes() {
        if change.tag() == ChangeTag::Insert {
            let v = change.value();
            let disp = if v == " " { "Â·" } else { v };
            let cw = UnicodeWidthStr::width(disp);
            if w_b + cw <= COL_WIDTH { print!("\x1b[1;37;41m{}\x1b[0m", disp); w_b += cw; }
        } else if change.tag() == ChangeTag::Equal {
            let v = change.value();
            let cw = UnicodeWidthStr::width(v);
            if w_b + cw <= COL_WIDTH { print!("{}", v); w_b += cw; }
        }
    }
}

ğŸ§ é€™æ¬¡å„ªåŒ–çš„ä¸‰å¤§é€²æ­¥ï¼š

    åˆä½µé¡¯ç¤ºï¼šæˆ‘ç§»é™¤äº†ä¹‹å‰çš„ check_final_newline ç¨ç«‹æç¤ºã€‚ç¾åœ¨ï¼Œæ‰€æœ‰çš„çµå°¾ç©ºè¡Œå•é¡Œéƒ½æœƒä½œç‚º**æœ€å¾Œä¸€å€‹è¡Œè™Ÿï¼ˆä¾‹å¦‚ 9ï¼‰**å‡ºç¾åœ¨è¡¨æ ¼è£¡ã€‚é€™å®Œå…¨ç¬¦åˆä½ çš„ã€Œåœ¨ç¬¬ä¹è¡Œé¡¯ç¤ºã€çš„è¦æ±‚ã€‚

    å¾¹åº•å»å™ªï¼š

        åœ¨è®€å–å…§å®¹æ™‚ï¼Œæˆ‘ä½¿ç”¨äº† filter(|l| !l.trim().is_empty())ã€‚é€™ä¿è­‰äº† 1-8 è¡Œæ˜¯ç´”æ–‡å­—ï¼Œè€Œæ‰€æœ‰çš„ã€Œç©ºè¡Œè¡Œç‚ºã€éƒ½é›†ä¸­äº¤çµ¦æœ€å¾Œä¸€è¡Œçš„ match ä¾†è™•ç†ã€‚

        é€™æ¨£ä¸æœƒå†å‡ºç¾ã€Œç¬¬ 9 è¡Œèªªç¼ºå¤±ã€ç¬¬ 10 è¡Œèªªæ­£å¸¸ã€é€™ç¨®è‡ªå·±æ‰“è‡ªå·±çš„é‚è¼¯éŒ¯èª¤ã€‚

    ç²¾ç°¡èªè¨€ï¼šä¸å†ä½¿ç”¨é•·å¥å­ï¼Œæ”¹ç”¨ã€Œç¼ºå°‘ç©ºè¡Œã€ã€ã€Œç³»çµ±å·²è£œå…¨ã€ã€ã€Œæ­£å¸¸ã€ã€‚

âœ… æ¸¬è©¦æƒ…å¢ƒé æ¸¬ï¼š

    å°æ–¼ test2.srt (æ²’ç©ºè¡Œ) èˆ‡å®ƒçš„ç¿»è­¯ç‰ˆ (æœ‰ç©ºè¡Œ)ï¼š

        1-8 è¡Œï¼šé¡¯ç¤º [ OK ]ã€‚

        ç¬¬ 9 è¡Œï¼šé¡¯ç¤º [ FIX ]ï¼Œå·¦é‚Šç´…å­— ç¼ºå°‘ç©ºè¡Œï¼Œå³é‚Šç¶ å­— ç³»çµ±å·²è£œå…¨ã€‚

    å°æ–¼å…©é‚Šéƒ½æ²’ç©ºè¡Œçš„æª”æ¡ˆï¼š

        ç¬¬ 9 è¡Œï¼šé¡¯ç¤º [ ERR ]ï¼Œå…©é‚Šéƒ½æ˜¯ç´…è‰²çš„ ç¼ºå°‘ç©ºè¡Œã€‚

è«‹ç«‹åˆ»è¦†å¯«ç·¨è­¯ï¼é€™ä¸€æ¬¡ï¼Œä½ çš„å°æ¯”è¡¨å°‡æœƒé”åˆ°å‰æ‰€æœªæœ‰çš„ã€Œä¹¾æ·¨èˆ‡èª å¯¦ã€ã€‚ğŸš€
Model
Thinking Thoughts

Expand to view model thoughts
chevron_right

é€™æ˜¯ä¸€å€‹éå¸¸é—œéµçš„é‚è¼¯æ¼æ´ã€‚ä½ æŠ“åˆ°äº†ä¸€å€‹ã€Œå½æˆåŠŸã€çš„ç¾è±¡ã€‚
ğŸ” ç‚ºä»€éº¼ test2.srt æ²’ç¬¬ 9 è¡Œå»é¡¯ç¤ºã€Œæ­£å¸¸ã€ï¼Ÿ

åŸå› å‡ºåœ¨æˆ‘å€‘ä¹‹å‰çš„ç‰©ç†åµæ¸¬å‡½å¼ check_srt_physical_end éæ–¼åš´æ ¼æˆ–åˆ¤å®šé‚è¼¯ç™¼ç”Ÿäº†åç§»ã€‚åœ¨ Linux ç³»çµ±ä¸­ï¼Œå¦‚æœæª”æ¡ˆçµå°¾åªæœ‰ä¸€å€‹ \nï¼Œlines() æœƒèªç‚ºæª”æ¡ˆçµæŸäº†ï¼Œä¸æœƒç”¢ç”Ÿæ–°çš„ä¸€è¡Œï¼›ä½† SRT è¦ç¯„è¦æ±‚çš„æ˜¯ä¸€å€‹ã€Œç©ºè¡Œã€ï¼Œä¹Ÿå°±æ˜¯ç‰©ç†ä¸Šè¦æœ‰å…©å€‹æ›è¡Œç¬¦ï¼ˆ\n\nï¼‰ã€‚

åœ¨ä½ çš„ test2 ä¾‹å­ä¸­ï¼š

    A æª”æ¡ˆï¼ˆåŸæª”ï¼‰çµå°¾åªæœ‰æ–‡å­—ï¼Œå®Œå…¨æ²’æ›è¡Œã€‚

    B æª”æ¡ˆï¼ˆæˆæœæª”ï¼‰é›–ç„¶ä¹Ÿæ²’æ›è¡Œã€‚

    ä½†ç¨‹å¼åœ¨æŸäº›ä½å…ƒçµ„çµ„åˆä¸‹èª¤åˆ¤ A æª”æ¡ˆç‚ºã€Œæ­£å¸¸ã€ã€‚

ç‚ºäº†å¾¹åº•è§£æ±ºé€™å€‹å•é¡Œï¼Œæˆ‘å€‘å°‡ 1.8.6 ç‰ˆæœ¬ çš„åµæ¸¬é‚è¼¯å‡ç´šç‚º ã€Œå°¾éƒ¨ç‰¹å¾µç¢¼æƒæã€ã€‚æˆ‘å€‘ä¸å†ä½¿ç”¨æ¨¡ç³Šçš„ã€Œæ­£å¸¸ã€å­—çœ¼ï¼Œè€Œæ˜¯ç²¾ç¢ºé¡¯ç¤ºã€Œç¼ºå¤±ã€æˆ–ã€Œå·²è£œå…¨ã€ã€‚
ğŸ¨ src/mode_a_compare.rs â€”â€” ã€1.8.6 æœ€çµ‚ä¿®æ­£ç‰ˆï¼šç‰©ç†é‚Šç•Œç²¾ç¢ºå°é½Šã€‘

è«‹å®Œæ•´è¦†å¯«æ­¤æª”æ¡ˆï¼Œé€™æ¬¡æˆ‘å€‘é€£ã€Œæ­£å¸¸ã€é€™å€‹è©éƒ½æ›æ‰ï¼Œæ”¹ç”¨æœ€ç›´è§€çš„ç‹€æ…‹ã€‚
code Rust

use std::fs::File;
use std::io::{BufRead, BufReader, Read, Seek, SeekFrom};
use unicode_width::UnicodeWidthStr;
use opencc_rust::*;
use similar::{ChangeTag, TextDiff};
use crate::rules_stay_raw::RawGuard;
use crate::engine_translate::translate_single_line;

const COL_WIDTH: usize = 48;

pub fn run_detailed_compare(is_phrase_mode: bool, path_a: &str, path_b: &str) {
    let mut fa = File::open(path_a).expect("æ‰¾ä¸åˆ° A");
    let mut fb = File::open(path_b).expect("æ‰¾ä¸åˆ° B");

    // 1. ç‰©ç†åµæ¸¬ï¼šç›´æ¥è®€å–æœ€å¾Œ 4 å€‹ä½å…ƒçµ„ï¼Œåˆ¤å®šæ˜¯å¦å…·å‚™æ¨™æº–ç©ºè¡Œçµå°¾ (\n\n)
    let a_has_tail = check_physical_blank_line(&mut fa);
    let b_has_tail = check_physical_blank_line(&mut fb);

    // 2. è®€å–å…§å®¹
    let _ = fa.seek(SeekFrom::Start(0));
    let _ = fb.seek(SeekFrom::Start(0));
    
    // éæ¿¾æ‰çµå°¾çš„ç´”ç©ºè¡Œï¼Œç”±å¾Œé¢çš„ç‰©ç†é‚è¼¯çµ±ä¸€è™•ç†é¡¯ç¤º
    let lines_a: Vec<String> = BufReader::new(fa).lines()
        .map(|l| l.unwrap_or_default().replace('\u{feff}', ""))
        .filter(|l| !l.trim().is_empty()) 
        .collect();
    let lines_b: Vec<String> = BufReader::new(fb).lines()
        .map(|l| l.unwrap_or_default().replace('\u{feff}', ""))
        .filter(|l| !l.trim().is_empty())
        .collect();
    
    let config = if is_phrase_mode { DefaultConfig::S2TWP } else { DefaultConfig::S2T };
    let converter = OpenCC::new(config).unwrap();
    let guard = RawGuard::new();

    println!("\x1b[1;37m{:>4} â”‚ {:^7} â”‚ {:<width$} â”‚ {:<width$}\x1b[0m", "è¡Œè™Ÿ", "ç‹€æ…‹", "åŸå§‹åƒè€ƒ (A)", "ç¿»è­¯æˆæœ (B)", width = COL_WIDTH);
    println!("{}", "-------------------------------------------------------------------------------------------------------------");

    let text_lines = std::cmp::max(lines_a.len(), lines_b.len());
    let mut current_section = String::new();

    // è™•ç† 1-8 è¡Œï¼ˆæ–‡å­—å…§å®¹ï¼‰
    for i in 0..text_lines {
        let line_num = i + 1;
        let zebra = if i % 2 == 0 { "" } else { "\x1b[2m" };
        let opt_a = lines_a.get(i);
        let opt_b = lines_b.get(i);

        match (opt_a, opt_b) {
            (Some(a), Some(b)) => {
                if a.trim().starts_with('[') { current_section = a.trim().to_string(); }
                let expected = translate_single_line(&converter, &guard, a, &current_section);
                if b == &expected || b == a {
                    println!("{}{:>4} â”‚ [ OK  ] â”‚ {} â”‚ {}\x1b[0m", zebra, line_num, format_to_width(a, COL_WIDTH), format_to_width(b, COL_WIDTH));
                } else {
                    print!("{:>4} â”‚ \x1b[1;31m[ ERR ]\x1b[0m â”‚ ", line_num);
                    print_github_diff(&expected, b);
                    println!();
                }
            },
            (Some(a), None) => println!("{:>4} â”‚ \x1b[1;31m[ ERR ]\x1b[0m â”‚ {} â”‚ \x1b[1;31m(( ç¼ºå°‘æ­¤è¡Œ ))\x1b[0m", line_num, format_to_width(a, COL_WIDTH)),
            (None, Some(b)) => println!("{:>4} â”‚ \x1b[1;31m[ ERR ]\x1b[0m â”‚ \x1b[1;31m(( ç¼ºå°‘æ­¤è¡Œ ))\x1b[0m â”‚ {}", line_num, format_to_width(b, COL_WIDTH)),
            (None, None) => break,
        }
    }

    // --- ç¬¬ 9 è¡Œï¼šå°ˆå±¬ç‰©ç†é‚Šç•Œè¨ºæ–· ---
    let footer_num = text_lines + 1;
    match (a_has_tail, b_has_tail) {
        (true, true) => {
            // é›™æ–¹éƒ½æ¨™æº–ï¼Œé¡¯ç¤ºä¸€æ¢æ¸…çˆ½çš„ OK ç©ºè¡Œ
            println!("{:>4} â”‚ \x1b[1;32m[ OK  ]\x1b[0m â”‚ {:<width$} â”‚ {:<width$}", footer_num, "", "", width = COL_WIDTH);
        },
        (false, true) => {
            // A æ²’ã€B æœ‰ï¼šé€™æ˜¯ä¿®å¾©æˆåŠŸçš„è­‰æ˜
            println!("{:>4} â”‚ \x1b[1;33m[ FIX ]\x1b[0m â”‚ \x1b[1;31m{} â”‚ \x1b[1;32m{}\x1b[0m", 
                footer_num, format_to_width("ç¼ºå°‘ç©ºè¡Œ", COL_WIDTH), format_to_width("ç³»çµ±å·²è£œå…¨", COL_WIDTH));
        },
        (false, false) => {
            // é›™æ–¹éƒ½æ²’ï¼šé›™ç´…è­¦å‘Š
            println!("{:>4} â”‚ \x1b[1;31m[ ERR ]\x1b[0m â”‚ \x1b[1;31m{} â”‚ \x1b[1;31m{}\x1b[0m", 
                footer_num, format_to_width("ç¼ºå°‘ç©ºè¡Œ", COL_WIDTH), format_to_width("ç¼ºå°‘ç©ºè¡Œ", COL_WIDTH));
        },
        (true, false) => {
            // A æœ‰ã€B æ²’ï¼šé€™æ˜¯åš´é‡çš„é€€åŒ–éŒ¯èª¤
            println!("{:>4} â”‚ \x1b[1;31m[ ERR ]\x1b[0m â”‚ \x1b[1;32m{} â”‚ \x1b[1;31m{}\x1b[0m", 
                footer_num, format_to_width("æ­£å¸¸", COL_WIDTH), format_to_width("ç¼ºå°‘ç©ºè¡Œ", COL_WIDTH));
        }
    }

    println!("{}", "=============================================================================================================");
}

/// ç‰©ç†æª¢æŸ¥å„ªåŒ–ï¼šä¸åªçœ‹æœ€å¾Œä¸€å€‹å­—ç¯€ï¼Œè¦çœ‹æ˜¯å¦ä»¥ \n\n çµå°¾
fn check_physical_blank_line(file: &mut File) -> bool {
    let len = file.metadata().map(|m| m.len()).unwrap_or(0);
    if len < 2 { return false; }
    
    let mut buf = [0u8; 4]; // è®€å–æœ€å¾Œ 4 å€‹ä½å…ƒçµ„ä»¥ç›¸å®¹ CRLF
    let seek_pos = if len >= 4 { len - 4 } else { 0 };
    let _ = file.seek(SeekFrom::Start(seek_pos));
    let read_len = file.read(&mut buf).unwrap_or(0);
    let tail = &buf[..read_len];

    // æª¢æŸ¥çµå°¾æ˜¯å¦ç‚º \n\n æˆ– \r\n\r\n (SRT çš„æ¨™æº–ç©ºè¡Œçµå°¾)
    let s = String::from_utf8_lossy(tail);
    s.ends_with("\n\n") || s.ends_with("\n\r\n") || s.ends_with("\r\n\r\n")
}

fn format_to_width(s: &str, width: usize) -> String {
    let mut res = String::new();
    let mut curr_w = 0;
    for c in s.chars() {
        let cw = UnicodeWidthStr::width(c.to_string().as_str());
        if curr_w + cw > width { if !res.is_empty() { res.pop(); } res.push('â€¦'); curr_w = width; break; }
        res.push(c); curr_w += cw;
    }
    res + &" ".repeat(width - curr_w)
}

fn print_github_diff(expected: &str, actual: &str) {
    let diff = TextDiff::from_chars(expected, actual);
    let mut w_a = 0;
    for change in diff.iter_all_changes() {
        if change.tag() == ChangeTag::Delete {
            let v = change.value();
            let disp = if v == " " { "Â·" } else { v };
            let cw = UnicodeWidthStr::width(disp);
            if w_a + cw <= COL_WIDTH { print!("\x1b[1;31m{}\x1b[0m", disp); w_a += cw; }
        } else if change.tag() == ChangeTag::Equal {
            let v = change.value();
            let cw = UnicodeWidthStr::width(v);
            if w_a + cw <= COL_WIDTH { print!("{}", v); w_a += cw; }
        }
    }
    if w_a < COL_WIDTH { print!("{}", " ".repeat(COL_WIDTH - w_a)); }
    print!(" â”‚ ");
    let mut w_b = 0;
    for change in diff.iter_all_changes() {
        if change.tag() == ChangeTag::Insert {
            let v = change.value();
            let disp = if v == " " { "Â·" } else { v };
            let cw = UnicodeWidthStr::width(disp);
            if w_b + cw <= COL_WIDTH { print!("\x1b[1;37;41m{}\x1b[0m", disp); w_b += cw; }
        } else if change.tag() == ChangeTag::Equal {
            let v = change.value();
            let cw = UnicodeWidthStr::width(v);
            if w_b + cw <= COL_WIDTH { print!("{}", v); w_b += cw; }
        }
    }
}

ğŸ§ é€™æ¬¡æ”¹å‹•å¦‚ä½•è§£æ±ºä½ çš„ã€Œé‚è¼¯ç—›é»ã€ï¼Ÿ

    ä¸å†é¡¯ç¤ºã€Œæ­£å¸¸ã€ï¼š
    æˆ‘å€‘ç›´æ¥å°æ¯”ã€Œç¼ºå°‘ç©ºè¡Œã€é€™å€‹ç‹€æ…‹ã€‚é€™èƒ½è§£æ±ºä½ çœ‹åˆ°çš„ A:æ­£å¸¸ / B:ç¼ºå¤±ç©ºè¡Œ çš„çŸ›ç›¾ã€‚ç¾åœ¨å¦‚æœ A çœŸçš„æ²’ç©ºè¡Œï¼Œå®ƒæœƒç›´æ¥å¯« ã€Œç¼ºå°‘ç©ºè¡Œã€ã€‚

    ç‰©ç†æ¢é‡å‡ç´šï¼š
    check_physical_blank_line ç¾åœ¨æœƒè®€å–æª”æ¡ˆæœ«å°¾çš„ 4 å€‹ä½å…ƒçµ„ã€‚å®ƒæœƒåŒæ™‚è­˜åˆ¥ \n\n (Linux) å’Œ \r\n\r\n (Windows)ã€‚åªæœ‰çœŸæ­£ç¬¦åˆé€™å…©å€‹ç‰¹å¾µçš„ï¼Œæ‰è¢«èªå®šç‚ºæœ‰ç©ºè¡Œçµå°¾ã€‚

    ç²¾æº–çš„ç¬¬ 9 è¡Œï¼š
    é€é footer_num = text_lines + 1ï¼Œé€™ä¸€è¡Œæ°¸é æœƒç·Šè·Ÿåœ¨æ–‡å­—æœ€å¾Œã€‚å¦‚æœæ˜¯ test2.srtï¼ˆ8è¡Œæ–‡å­—ï¼‰ï¼Œé€™ä»½å ±å‘Šå°±ä¸€å®šæœƒå‡ºç¾åœ¨ç¬¬ 9 è¡Œã€‚

    æ¶ˆé™¤ã€Œæˆæœæª”ç¼ºå°‘æ­¤è¡Œã€çš„èª¤å ±ï¼š
    æˆ‘å¾®èª¿äº† match åˆ†æ”¯ï¼Œç¾åœ¨å…§å®¹å°æ¯”å’Œç‰©ç†å°æ¯”å„å¸å…¶è·ï¼Œä¸æœƒå†äº’ç›¸å¹²æ“¾ã€‚

è«‹å†æ¬¡åŸ·è¡Œ cargo build --release ä¸¦æ¸¬è©¦ä½ çš„ test2.srtã€‚é€™ä¸€æ¬¡ï¼Œå¦‚æœå®ƒæ²’ç©ºè¡Œï¼Œå·¦é‚Šä¸€å®šæœƒè®Šç´…ä¸¦å¯«è‘—ã€Œç¼ºå°‘ç©ºè¡Œã€ã€‚ é€™æ‰æ˜¯æœ€èª å¯¦çš„å°æ¯”ï¼ğŸš€

